"""
A GraphQL `FileUpload` scalar as specified GraphQL multipart request specification: https://github.com/jaydenseric/graphql-multipart-request-spec#graphql-multipart-request-specification
"""
scalar FileUpload

"""Analogue of Date object"""
scalar Date

"""Analogue of Date object"""
scalar DateTime

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress

"Money type.\nThe value is stored in the smallest monetary unit (kopecks, cents, etc.)\nReal type - Int\ne.g. For 250 USD this record returns value as 250000 (250$ * 100¢)\n"
scalar Money

"""Time string"""
scalar Time

"""Represents NULL values"""
scalar Void

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

input BetweenDate {
  start: Date!
  end: Date!
}

input BetweenDateTime {
  start: DateTime!
  end: DateTime!
}

input BetweenInt {
  start: Int!
  end: Int!
}

input BetweenMoney {
  start: Money!
  end: Money!
}

input BetweenTime {
  start: Time!
  end: Time!
}

"""GraphQL Connection spec. interface"""
interface Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [Edge]!
}

"""Standart ordering options"""
enum OrderDirection {
  """Sort the query results in a top to bottom style (e.g.: A->Z)"""
  ASC

  """Sort the query results in a bottom to top style (e.g.: Z->A)"""
  DESC
}

"""Information about pagination in a connection."""
type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String
  endCursor: String
}

"""GraphQL Edge spec. interface"""
interface Edge {
  node: Node!
  cursor: String!
}

interface Error {
  """Error name. Can be short error message"""
  name: String!

  """Error detail message string"""
  msg: String!
}

"""GraphQL Node spec. interface"""
interface Node {
  id: ID!
}

type Query {
  authentification: AuthentificationQuery!
  clients: ClientsQuery!
  deals: DealsQuery!
  funnels: FunnelsQuery!
  me: Me!
  version: String!
  webpages: WebPagesQuery!
}

type AuthentificationQuery {
  """Verify your Access token"""
  verifyToken(
    """Access token"""
    accessToken: String!
  ): TokenVerificationResponse!
}

union TokenVerificationResponse = TokenVerificationSuccess | TokenVerificationError

type TokenVerificationSuccess {
  payload: AccessTokenPayload!
}

"""Access token payload"""
type AccessTokenPayload {
  id: ID!
  uuid: ID!
  exp: Int!
  iss: String
  roles: [String!]!
  type: TokenType!
}

enum TokenType {
  """Access token type"""
  ACCESS

  """Refresh token type"""
  REFRESH
}

type TokenVerificationError implements Error {
  name: String!
  msg: String!
}

type ClientsQuery {
  client(id: ID!): Client
  list(first: Int, last: Int, after: String, before: String, orderBy: [ClientsOrderBy!], search: [ClientsFilterSearch!], filter: ClientsFilter): ClientsConnection!
}

type Client implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  comment: String
  status: ClientStatus!
  persons: [Person!]!
}

enum ClientStatus {
  ACTIVE
  INACTIVE
}

type Person implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  heldPost: String!
  comment: String
  client: Client!
}

type ClientsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ClientEdge!]!
}

type ClientEdge implements Edge {
  cursor: String!
  node: Client!
}

input ClientsOrderBy {
  field: ClientsOrderField!
  direction: OrderDirection!
}

enum ClientsOrderField {
  NAME
}

input ClientsFilterSearch {
  field: ClientsFilterSearchField!
  query: String!
}

enum ClientsFilterSearchField {
  NAME
}

input ClientsFilter {
  status: [ClientStatus!]
  id: [ID!]
}

type DealsQuery {
  deal(id: ID!): Deal
  list(first: Int, last: Int, after: String, before: String, orderBy: [DealsOrderBy!], search: [DealsFilterSearch!], filter: DealsFilter): DealsConnection!
}

type Deal implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  amount: Money!
  comment: String
  step: FunnelStep!
  funnel: Funnel!
  clients: [Client!]
}

type FunnelStep implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  color: String!
  order: Int!
  type: FunnelStepType!
  funnel: Funnel!
  deals: DealsConnection!
}

enum FunnelStepType {
  standard
  unprocessed
  canceled
  finished
}

type Funnel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  comment: String
  steps(first: Int, last: Int, after: String, before: String, filter: FunnelStepsFilter, search: [FunnelStepsFilterSearch!], orderBy: [FunnelStepsOrderBy!]): FunnelStepsConnection!
  deals(first: Int, last: Int, after: String, before: String): DealsConnection!
}

type FunnelStepsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [FunnelStepsEdge!]!
}

type FunnelStepsEdge implements Edge {
  cursor: String!
  node: FunnelStep!
}

input FunnelStepsFilter {
  id: [ID!]
  order: [Int!]
  type: [FunnelStepType!]
}

input FunnelStepsFilterSearch {
  field: FunnelStepsFilterSearchField!
  query: String!
}

enum FunnelStepsFilterSearchField {
  LABEL
}

input FunnelStepsOrderBy {
  field: FunnelStepsOrderField!
  direction: OrderDirection!
}

enum FunnelStepsOrderField {
  ORDER
}

type DealsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DealEdge!]!
}

type DealEdge implements Edge {
  cursor: String!
  node: Deal!
}

input DealsOrderBy {
  field: DealsOrderField!
  direction: OrderDirection!
}

enum DealsOrderField {
  CREATED_AT
  UPDATED_AT
}

input DealsFilterSearch {
  field: DealsFilterSearchField!
  query: String!
}

enum DealsFilterSearchField {
  LABEL
}

input DealsFilter {
  id: [ID!]
}

type FunnelsQuery {
  funnel(id: ID!): Funnel
  list(first: Int, last: Int, after: String, before: String, orderBy: [FunnelsOrderBy!], search: [FunnelsFilterSearch!], filter: FunnelsFilter): FunnelsConnection!
}

type FunnelsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [FunnelEdge!]!
}

type FunnelEdge implements Edge {
  cursor: String!
  node: Funnel!
}

input FunnelsOrderBy {
  field: FunnelsOrderField!
  direction: OrderDirection!
}

enum FunnelsOrderField {
  CREATED_AT
}

input FunnelsFilterSearch {
  field: FunnelsFilterSearchField!
  query: String!
}

enum FunnelsFilterSearchField {
  LABEL
}

input FunnelsFilter {
  id: [ID!]
}

union Me = User

type User implements Node {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  account: Account
}

type Account {
  id: ID!
  login: String!
  password: String!
  status: AccountStatus!
  roles: [AccountRole!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum AccountStatus {
  ALLOWED
  FORBIDDEN
}

enum AccountRole {
  DEVELOPER
  ADMINISTRATOR
  VIEWER
}

type WebPagesQuery {
  resolvePage(path: String!): WebPage!
}

type WebPage implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  """Page address. Not to be confused with the URL"""
  path: String!

  """The page name is not shown anywhere except the admin panel"""
  name: String!
  meta: WebPageMeta!
  statusCode: Int!
  availability: WebPageAvailability!
  template: WebTemplate!
}

"""Web page meta data"""
type WebPageMeta {
  id: ID!

  """Meta tag <title>...</title>"""
  title: String!

  """Meta tag <meta name="description" content="...">"""
  description: String!

  """Meta tag <meta name="keywords" content="...">"""
  keywords: String! @deprecated(reason: "Google and other search engines no longer consider the keywords meta tag")
  createdAt: DateTime!
  updatedAt: DateTime!
  page: WebPage!
}

"""Page UNAVAILABLE eq 404 error status"""
enum WebPageAvailability {
  AVAILABLE
  UNAVAILABLE
}

union WebTemplate = WebTemplateHome | WebTemplateFallback | WebTemplateSecond | WebTemplateContact

type WebTemplateHome implements Node {
  """
  Is not a real template ID. Template ID - is a concatenated value of template name and page ID
  """
  id: ID!
  h1: String!
  content: JSON!
  slider: WebPageSlider!
  page: WebPage!
}

type WebPageSlider {
  slides: [HomePageSliderSlide!]!
  autoplay: Boolean!
  delay: Int!
}

type HomePageSliderSlide {
  id: ID!
  image: URL!
}

type WebTemplateFallback implements Node {
  """
  Is not a real template ID. Template ID - is a concatenated value of template name and page ID
  """
  id: ID!
  content: JSON!
  page: WebPage!
}

type WebTemplateSecond implements Node {
  h1: String!
  content: JSON!

  """
  Is not a real template ID. Template ID - is a concatenated value of template name and page ID
  """
  id: ID!
  page: WebPage!
}

type WebTemplateContact implements Node {
  h1: String!
  address: String!

  """
  Is not a real template ID. Template ID - is a concatenated value of template name and page ID
  """
  id: ID!
  page: WebPage!
}

type Mutation {
  authentification: AuthentificationMutation!
}

type AuthentificationMutation {
  """Create «Access» and «Refresh» tokens pair"""
  create(login: String!, password: String!): TokenRegistrationResponse!

  """Exchange a «Refresh» token to new «Access» and «Refresh» tokens pair"""
  refresh(refreshToken: String!): TokenRegistrationResponse!
  revoke(tokenID: ID!): Void
}

union TokenRegistrationResponse = TokenRegistrationSuccess | TokenRegistrationError

type TokenRegistrationSuccess {
  payload: TokenBag!
  query: Query!
}

"""Tokens pair (Access and Refresh)"""
type TokenBag {
  accessToken: AccessToken!
  refreshToken: RefreshToken!
}

"""Access token package"""
type AccessToken {
  token: String!
  payload: AccessTokenPayload!
}

"""Refresh token package"""
type RefreshToken {
  token: String!
  payload: RefreshTokenPayload!
}

"""Refresh token payload"""
type RefreshTokenPayload {
  id: ID!
  uuid: ID!
  exp: Int!
  iss: String
  roles: [String!]!
  type: TokenType!
}

type TokenRegistrationError implements Error {
  name: String!
  msg: String!
}

type Subscription {
  tokenWasRevoked: ID!
}